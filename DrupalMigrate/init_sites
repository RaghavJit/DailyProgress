#!/bin/bash

testInput() {
    local user_exists confirm

    if [[ "$SITE_NAME" != "${SITE_NAME,,}" || "$SITE_NAME" =~ [[:space:]] ]]; then
        echo "Error: Site name must be lowercase only with no spaces."
        exit 1
    fi

    if [[ "$SITE_DB_NAME" != "${SITE_DB_NAME,,}" || "$SITE_DB_NAME" =~ [[:space:]] ]]; then
        echo "Error: DB name must be lowercase only with no spaces."
        exit 1
    fi

    if [[ ! -f "$SITE_DB_DUMP" ]]; then
        echo "Error: SQL dump file '$SITE_DB_DUMP' does not exist."
        exit 1
    fi

    if [[ "$SITE_DB_USERNAME" != "${SITE_DB_USERNAME,,}" || "$SITE_DB_USERNAME" =~ [[:space:]] ]]; then
        echo "Error: Database username must be lowercase only with no spaces."
        exit 1
    fi

    if ! sudo mysql -u root -p"$ROOTPASS" -e "SELECT 1;" 2> >(grep -v "Using a password on the command line" >&2); then
        echo "Error: Invalid MySQL root password or MySQL server not running."
        exit 1
    fi

    if [[ "$SITE_VERSION" == "10" ]]; then
        SITE_VERSION="Dockerfile"
    elif [[ "$SITE_VERSION" == "11" ]]; then
        SITE_VERSION="Dockerfile.11"
    else
        echo "Error: Invalid Drupal Version (Choose 10 or 11)."
        exit 1
    fi

    user_exists=$(sudo mysql -u root -p"$ROOTPASS" -sse "SELECT COUNT(*) FROM mysql.user WHERE user='$SITE_DB_USERNAME'" 2> >(grep -v "Using a password on the command line" >&2))

    if [[ "$user_exists" -ne 0 ]]; then
        echo "Alert: MySQL user '$SITE_DB_USERNAME' already exists."
        read -r -p "Do you wish to use this username? (y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            echo "Going ahead with $SITE_DB_USERNAME..."
            read -s -p "Enter the password of the user: " SITE_DB_PASSWD
            echo

            return 0
        else
            exit 1
        fi
    fi
}

getInput() {

    if [[ DB_CONFIG -eq 1 ]]; then
        echo "Reading Configuration from sites.json file."
        return 0;
    fi

    local tmp_rootpass tmp_site_db_username tmp_site_db_name tmp_site_db_dump tmp_site_name tmp_site_version tmp_site_branch
    local tag confirm tmp_repo branches

    while true; do
        read -s -p "Enter MySQL root password: " tmp_rootpass
        echo
        echo "!! Kindly use lowercase for naming and don't include white spaces !!"
        read -r -p "Enter name of the site: " tmp_site_name
        read -r -p "Enter name of site database: " tmp_site_db_name
        read -r -p "Add date tag to database name? [default: _$(date +%Y_%m_%d)]: " tag
        tag=${tag:-_$(date +%Y_%m_%d)}
        tmp_site_db_name="${tmp_site_db_name}${tag}"
        read -r -p "Enter database username you wish to use: " tmp_site_db_username
        read -r -p "Enter path to SQL dumpfile for site: " tmp_site_db_dump
        read -r -p "Choose Drupal version for site (10, 11): " tmp_site_version
        echo "Select a branch to clone from the below options:"
        echo

        mapfile -t lines < <(
            jq -r --arg site_name "$tmp_site_name" '
              .[] | select(.SITE_NAME == $site_name) |
              "\(.REPO)"
            ' sites.json
        )

        if [ "${#lines[@]}" -ne 1 ]; then
            echo "Error: Could not extract REPO for $tmp_site_name"
            return 1
        fi
        tmp_repo="${lines[0]}"
        
        branches=($(git ls-remote --heads "$tmp_repo" | awk '{print $2}' | sed 's#refs/heads/##'))

        echo "Available branches:"
        select b in "${branches[@]}"; do
            if [[ -n "$b" ]]; then
                tmp_site_branch="$b"
                break
            else
                echo "Invalid choice."
            fi
        done

        echo "Summary of entered information:"
        echo "Site Name        : $tmp_site_name"
        echo "Site Branch      : $tmp_site_branch"
        echo "Database Name    : $tmp_site_db_name"
        echo "Database Username: $tmp_site_db_username"
        echo "SQL Dump File    : $tmp_site_db_dump"
        echo "Image Name       : ${tmp_site_name}_image"
        echo "Container Name   : ${tmp_site_name}_container"
        echo "Service Name     : ${tmp_site_name}_persist"
        echo "Drupal Version   : $tmp_site_version"
        echo

        read -r -p "Is this information correct? (Y/n): " confirm
        if [[ -z "$confirm" || "$confirm" =~ ^[Yy]$ ]]; then
            ROOTPASS="$tmp_rootpass"
            SITE_NAME="$tmp_site_name"
            SITE_BRANCH="$tmp_site_branch"
            SITE_VERSION="$tmp_site_version"
            SITE_DB_USERNAME="$tmp_site_db_username"
            SITE_DB_DUMP="$tmp_site_db_dump"
            SITE_SERVICE="${tmp_site_name}_persist"
            SITE_IMAGE="${tmp_site_name}_image"
            SITE_CONTAINER="${tmp_site_name}_container"
            SITE_DB_NAME="${tmp_site_db_name}"
            SITE_DB_PASSWD=$(echo "$(tr -dc 'A-Z' </dev/urandom | head -c 1)$(tr -dc 'a-z' </dev/urandom | head -c 1)$(tr -dc '0-9' </dev/urandom | head -c 1)$(tr -dc '!@#$%^&*()_+=-[]{};:,.<>?' </dev/urandom | head -c 1)$(tr -dc 'A-Za-z0-9!@#$%^&*()_+=-[]{};:,.<>?' </dev/urandom | head -c 31)" | fold -w1 | shuf | tr -d '\n')

            echo "Confirmed! Continuing..."
            break
        else
            echo "Trying again..."
            echo
        fi
    done

    testInput &&
    echo "Config passed input validation."

    return 0
}

updateJSON() {

    local tmp_file

    if [[ "$DB_CONFIG" -eq 1 ]]; then
        echo "::: Skipping PHASE I :::"
        return 0
    fi

    echo "::: PHASE I - SITE CONFIGURATION AND SQL DUMP IMPORT :::"

    tmp_file=$(mktemp)

    if ! jq --arg site "$SITE_NAME" \
       --arg branch "$SITE_BRANCH" \
       --arg db "$SITE_DB_NAME" \
       --arg user "$SITE_DB_USERNAME" \
       --arg pass "$SITE_DB_PASSWD" \
       --arg service "$SITE_SERVICE" \
       --arg image "$SITE_IMAGE" \
       --arg container "$SITE_CONTAINER" \
       'map(
         if .SITE_NAME == $site then
           . + {
             "SITE_BRANCH": $branch,
             "SITE_DB_NAME": $db,
             "SITE_DB_USERNAME": $user,
             "SITE_DB_PASSWD": $pass,
             "SITE_IMAGE": $image,
             "SITE_CONTAINER": $container,
             "SITE_SERVICE": $service
           }
         else .
         end
       )' sites.json > "$tmp_file"; then

        echo "ERROR: jq failed"
        rm -f "$tmp_file"
        return 1
    fi

    if cmp -s sites.json "$tmp_file"; then
        echo "No changes in sites.json"
        rm -f "$tmp_file"
        return 1
    fi

    mv "$tmp_file" sites.json
    echo "Config saved to sites.json"
    return 0
}

createUserAndDB() {

    if [[ DB_CONFIG -eq 1 ]]; then
        echo "User and Database already created in previous run."
        return 0;
    fi

    local db_exists
    db_exists=$(sudo mysql -u root -p"$ROOTPASS" -sse "SHOW DATABASES LIKE '$SITE_DB_NAME'" 2> >(grep -v "Using a password on the command line" >&2))
    if [[ $? -ne 0 ]]; then
        echo "ERROR: Failed to check existing databases."
        return 1
    fi

    if [[ "$db_exists" == "$SITE_DB_NAME" ]]; then
        echo "Database '$SITE_DB_NAME' already exists. Skipping creation."
        return 0;
    fi

    echo "Creating database '$SITE_DB_NAME' and user '$SITE_DB_USERNAME'..."
    if ! sudo mysql -u root -p"$ROOTPASS" 2> >(grep -v "Using a password on the command line" >&2) <<EOF
CREATE DATABASE \`$SITE_DB_NAME\`;
CREATE USER '$SITE_DB_USERNAME'@'localhost' IDENTIFIED BY '$SITE_DB_PASSWD';
GRANT ALL PRIVILEGES ON \`$SITE_DB_NAME\`.* TO '$SITE_DB_USERNAME'@'localhost';
FLUSH PRIVILEGES;
EOF
    then
        echo "ERROR: Failed to create database or user."
        return 1
    fi

    return 0
}

importDump() {
    local confirm

    if [[ DB_CONFIG -eq 1 ]]; then
        return 0;
    fi

    echo "Importing ${SITE_DB_DUMP} to ${SITE_DB_NAME}"

     
    if ! sudo mysql -u root -p"$ROOTPASS" "$SITE_DB_NAME" < <(sed -e '/^CREATE DATABASE/d' -e '/^USE /d' "$SITE_DB_DUMP") 2> >(grep -v "Using a password on the command line" >&2); then

        echo "ERROR: SQL Dump import failed."
        return 1
    fi    

    echo "::: PHASE I - Completed successfully :::"
    read -r -p "Continue to PHASE II? (Y/n):" confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        exit;
    fi

    return 0;
}

cloneRepo() {
    local repo branch

    echo "::: PHASE II - BUILDING IMAGE AND CONTAINER :::"

    mapfile -t lines < <(
        jq -r --arg site_name "$SITE_NAME" '
          .[] | select(.SITE_NAME == $site_name) |
          "\(.REPO)\n\(.SITE_BRANCH)"
        ' sites.json
    )

    if [ "${#lines[@]}" -ne 2 ]; then
        echo "Error: Could not extract all 2 fields for $SITE_NAME"
        return 1
    fi

    repo="${lines[0]}"
    branch="${lines[1]}"

    rm -rf $(echo "$repo" | awk -F'/' '{gsub(/\.git$/, "", $NF); print $NF}')
    if ! git clone --branch ${branch} ${repo}; then
        echo "Error: Git clone failed"
        return 1;
    fi

    return 0;

}

createVolume() {
    local confirm
    local custom_name


    SITE_VOLUME="${SITE_NAME}_volume"

    if podman volume exists "$SITE_VOLUME"; then
        echo "Persistent volume '$SITE_VOLUME' already exists."
    else
        echo "Persistent volume for site '$SITE_NAME' does not exist."
    fi

    read -r -p "Do you want to create and use a new volume? [y/N]: " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        read -r -p "Enter custom volume name [default: $SITE_VOLUME]: " custom_name
        SITE_VOLUME="${custom_name:-$SITE_VOLUME}"
        podman volume create "$SITE_VOLUME"
        echo "Volume '$SITE_VOLUME' created."
    else
        echo "Using $SITE_VOLUME, new volume creation skipped."
    fi
}

createImage() {
    local port repo db_user site_image confirm
    local lines

    echo "SITE_NAME: $SITE_NAME"

    mapfile -t lines < <(
        jq -r --arg site_name "$SITE_NAME" '
          .[] | select(.SITE_NAME == $site_name) |
              "\(.PORT)\n\(.REPO)\n\(.SITE_DB_USERNAME)\n\(.SITE_IMAGE)"
        ' sites.json
    )

    if [ "${#lines[@]}" -ne 4 ]; then
        echo "Error: Could not extract all 4 fields for $SITE_NAME"
        return 1
    fi

    port="${lines[0]}"
    repo="${lines[1]}"
    db_user="${lines[2]}"
    site_image="${lines[3]}"

    repo=$(echo "$repo" | awk -F'/' '{gsub(/\.git$/, "", $NF); print $NF}')

    SITE_IMAGE=$site_image

    echo "Building Podman image with:"
    echo "Site Image Name  : $SITE_IMAGE"
    echo "Database Name    : $db_name"
    echo "Database Username: $db_user"
    echo "Repository       : $repo"
    echo

    if podman build -t "$SITE_IMAGE" -f "$SITE_VERSION" . \
        --build-arg REPO_DIR="$repo" \
        --build-arg ENV_USR="$db_user" \
        --build-arg ENV_HOST="10.0.2.2"; then
        return 0
    else
        echo "Error: Failed to build Podman image $SITE_IMAGE for site '$SITE_NAME'" >&2
        return 1
    fi
}

makePodmanSecrets() {
    local db_name db_pass
     
    mapfile -t lines < <(
        jq -r --arg site_name "$SITE_NAME" '
          .[] | select(.SITE_NAME == $site_name) |
              "\(.SITE_DB_NAME)\n\(.SITE_DB_PASSWD)"
        ' sites.json
    )

    if [ "${#lines[@]}" -ne 2 ]; then
        echo "Error: Could not extract all 2 fields for $SITE_NAME"
        return 1
    fi

    db_name="${lines[0]}"
    db_pass="${lines[1]}"

    echo "Making Podman secrets..."
    if ! printf "%s" "$db_name" | podman secret create "${SITE_NAME}_mysql_db" -; then
        echo "ERROR: Failed to create secret ${SITE_NAME}_mysql_db"
        return 1
    fi
    if ! printf "%s" "$db_pass" | podman secret create "${SITE_NAME}_mysql_password" -; then
        echo "ERROR: Failed to create secret ${SITE_NAME}_mysql_password"
        return 1
    fi
    
    return 0;
}

runContainer() {
    local port site_service site_image site_container

    mapfile -t lines < <(
        jq -r --arg site_name "$SITE_NAME" '
          .[] | select(.SITE_NAME == $site_name) |
          "\(.PORT)\n\(.SITE_IMAGE)\n\(.SITE_CONTAINER)\n\(.SITE_SERVICE)"
        ' sites.json
    )

    if [ "${#lines[@]}" -ne 4 ]; then
        echo "Error: Could not extract all 4 fields for $SITE_NAME to build container."
        return 1
    fi

    port="${lines[0]}"
    site_image="${lines[1]}"
    site_container="${lines[2]}"
    site_service="${lines[3]}"

    PORT=$port
    SITE_IMAGE=$site_image
    SITE_CONTAINER=$site_container
    SITE_SERVICE=$site_service

    mkdir -p ~/.config/containers/systemd

    echo "Writing container file to ~/.config/containers/systemd/${SITE_SERVICE}.container"
    cat > ~/.config/containers/systemd/${SITE_SERVICE}.container <<EOF
[Unit]
Description=${SITE_NAME} Persist Container
After=network-online.target
Wants=network-online.target

[Container]
Image=${SITE_IMAGE}:latest
Pull=never
AddCapability=NET_RAW
ContainerName=${SITE_CONTAINER}
PublishPort=${PORT}:80
Volume=${SITE_VOLUME}:/var/www/html/sites/default/files:Z
Network=slirp4netns:allow_host_loopback=true

[Service]
Restart=unless-stopped
TimeoutStartSec=1000

[Install]
WantedBy=default.target
EOF

    echo "Building Service to ~/.config/systemd/user/${SITE_SERVICE}.service"
    systemctl --user daemon-reload
    mkdir -p ~/.config/systemd/user
    cp /run/user/$(id -u)/systemd/generator/${site_service}.service ~/.config/systemd/user/

    echo "Adding Podman Secrets to service file"
    systemctl --user daemon-reload
    sed -i "/^ExecStart=/ s|\(${SITE_IMAGE}:latest\)| --secret ${SITE_NAME}_mysql_db,type=env,target=ENV_DB --secret ${SITE_NAME}_mysql_password,type=env,target=ENV_PSWD \1|" ~/.config/systemd/user/${SITE_SERVICE}.service


    echo "Starting service ${SITE_SERVICE}.service"

    systemctl --user enable ${site_service}.service
    systemctl --user start ${site_service}.service

    return 0
}

handleFailure() {
    local port repo db_name db_user db_pass site_image site_container site_service confirm
    local lines

    mapfile -t lines < <(
        jq -r --arg site_name "$SITE_NAME" '
          .[] | select(.SITE_NAME == $site_name) |
          "\(.PORT)\n\(.REPO)\n\(.SITE_DB_NAME)\n\(.SITE_DB_USERNAME)\n\(.SITE_DB_PASSWD)\n\(.SITE_IMAGE)\n\(.SITE_CONTAINER)\n\(.SITE_SERVICE)"
        ' sites.json
    )

    if [ "${#lines[@]}" -ne 8 ]; then
        echo "Error: Could not extract all 8 fields for $SITE_NAME"
        return 1
    fi

    port="${lines[0]}"
    repo="${lines[1]}"
    db_name="${lines[2]}"
    db_user="${lines[3]}"
    db_pass="${lines[4]}"
    site_image="${lines[5]}"
    site_container="${lines[6]}"
    site_service="${lines[7]}"

    repo=$(echo "$repo" | awk -F'/' '{gsub(/\.git$/, "", $NF); print $NF}')

    if [[ $DB_CONFIG -eq 2 ]]; then
        echo "This will delete the following:"
        echo "1. Configuration in sites.json"
        echo "2. Imported MySQL Database"
        echo "3. Image created"
        echo "4. Container"
        echo "5. Systemd service to auto restart container"
        read -p "Would you like to undo ALL the changes made by script for site "$SITE_NAME"? (y/N): " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo "No action taken"
            return 0;
        fi
    elif [[ $DB_CONFIG -eq 1 ]]; then
        echo "Some error occurred during PHASE II choose what to delete"
        echo "OPTION: Y will delete"
        echo "1. Image created"
        echo "2. Container"
        echo "3. Systemd service to auto restart container"
        echo "OPTION: N will delete"
        echo "1. Configuration in sites.json"
        echo "2. Imported MySQL Database"
        echo "3. Image created"
        echo "4. Container"
        echo "5. Systemd service to auto restart container"
        read -p "Choose action: " confirm
    elif [[ $DB_CONFIG -eq 0 ]]; then 
        echo "Error occurred, check input and try again. Would you like to deleting all changes (Y/n): " confirm
        if [[ "$confirm" =~ ^[Nn]$ ]]; then
            echo "Faulty site not deleted"
            return 0;
        fi
    fi


    if [[ $DB_CONFIG -eq 1 && "$confirm" =~ ^[Yy]$ ]]; then
        systemctl --user disable ${site_service}
        systemctl --user stop ${site_service}

        rm /run/user/$(id -u)/systemd/generator/${site_service}.service
        rm ${HOME}/.config/containers/systemd/${site_service}.container
        rm ${HOME}/.config/systemd/user/${site_service}.service

        podman container stop $site_container
        podman container rm $site_container
        podman image rm $site_image

        rm -rf ${repo}

        podman secret rm "${SITE_NAME}_mysql_db"
        podman secret rm "${SITE_NAME}_mysql_password"
    else
        systemctl --user disable ${site_service}
        systemctl --user stop ${site_service}

        rm /run/user/$(id -u)/systemd/generator/${site_service}.service
        rm ${HOME}/.config/containers/systemd/${site_service}.container
        rm ${HOME}/.config/systemd/user/${site_service}.service

        podman container stop $site_container
        podman container rm $site_container
        podman image rm $site_image

        rm -rf ${repo}

        podman secret rm "${SITE_NAME}_mysql_db"
        podman secret rm "${SITE_NAME}_mysql_password"

        sudo mysql -u root -p"$ROOTPASS" 2> >(grep -v "Using a password on the command line" >&2) <<EOF
DROP DATABASE \`$db_name\`;
DROP USER '$db_user'@'localhost';
FLUSH PRIVILEGES;
EOF

        jq --arg site "$SITE_NAME" \
           --arg db "" \
           --arg user "" \
           --arg pass "" \
           --arg service "" \
           --arg image "" \
           --arg container "" \
           'map(
             if .SITE_NAME == $site then
               . + {
                 "SITE_DB_NAME": $db,
                 "SITE_DB_USERNAME": $user,
                 "SITE_DB_PASSWD": $pass,
                 "SITE_IMAGE": $image,
                 "SITE_CONTAINER": $container,
                 "SITE_SERVICE": $service
               }
             else .
             end
           )' sites.json > tmp && mv tmp sites.json
    fi
}

PORT=""
REPO=""
SITE_BRANCH=""
SITE_NAME=""
SITE_VERSION=""
SITE_DB_NAME=""
SITE_DB_USERNAME=""
SITE_DB_PASSWD=""
SITE_VOLUME=""
SITE_IMAGE=""
SITE_CONTAINER=""
SITE_SERVICE=""
DB_CONFIG="0"

main() {

    if [[ $1 == "--resume" || $1 == "-r" ]]; then
        shift
        DB_CONFIG=1
        SITE_NAME=$1
    elif [[ $1 == "--delete" || $1 == "-d" ]]; then
        shift
        DB_CONFIG=2
        SITE_NAME=$1
        handleFailure
        return 0;
    fi

    {
        getInput &&
        updateJSON &&
        createUserAndDB &&
        importDump &&
        cloneRepo &&
        createVolume &&
        createImage && 
        makePodmanSecrets &&
        runContainer &&
        echo "::: Operation complete :::"
    } || {
        echo "!!! Operation Failed !!!"
        handleFailure
    }
}

time main "$@"

